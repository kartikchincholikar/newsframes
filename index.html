<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph News Frames Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f4f7f6;
        }

        .container {
            background-color: white;
            border-radius: 10px;
            padding: 20px 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        h1, h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }

        .input-area {
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        textarea {
            width: 95%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            min-height: 60px;
            margin-bottom: 15px;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1.5s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .message {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .error { color: #c0392b; background-color: #f9eaea; border: 1px solid #e74c3c; }
        .warning { color: #d35400; background-color: #fef5e7; border: 1px solid #f39c12; }
        .success { color: #27ae60; background-color: #eafaf1; border: 1px solid #a9dfbf; }

        .graph-visualization-area {
            margin-top: 30px;
            display: none;
        }

        .graph-flow {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .graph-stage {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
        }
        
        .parallel-group-stage { /* Specific class for stages holding parallel nodes */
            justify-content: space-around;
        }

        .graph-node {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            padding: 15px;
            margin: 5px 10px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 160px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .graph-node:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .graph-node.active {
            border-color: #3498db;
            background-color: #ddeeff;
            font-weight: bold;
        }
        .graph-node.error-node { border-left: 5px solid #e74c3c; background-color: #fcefee; }
        .graph-node.success-node { border-left: 5px solid #2ecc71; background-color: #e6f7f0; }

        .node-connector {
            font-size: 1.5em;
            color: #adb5bd;
            margin: 5px 0;
            text-align: center;
        }

        .node-details-area {
            margin-top: 20px;
            padding: 20px;
            background-color: #fdfefe;
            border: 1px solid #ecf0f1;
            border-radius: 8px;
            min-height: 100px;
        }
        .node-details-area h3 { text-align: left; margin-top: 0;}
        .node-details-area pre {
            background-color: #2c3e50;
            color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .final-output-area {
            margin-top: 30px;
            padding: 20px;
            background-color: #e6f7ff;
            border: 1px solid #aed6f1;
            border-radius: 8px;
            text-align: center;
        }
        .final-output-area h3 { color: #1f618d; }
        .final-output-area p { font-size: 1.1em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>LangGraph News Frames Visualizer</h1>

        <div class="input-area">
            <textarea id="headline-input" placeholder="Enter a news headline here..." rows="3"></textarea>
            <button id="generate-btn">Analyze with LangGraph</button>
        </div>

        <div id="loader" class="loader"></div>
        <div id="error-message" class="message error"></div>
        <div id="status-message" class="message"></div>

        <div class="graph-visualization-area" id="graph-viz-area">
            <h2>Graph Execution Flow</h2>
            <div class="graph-flow" id="dynamic-graph-flow">
                <!-- Graph nodes will be dynamically inserted here -->
            </div>

            <div class="node-details-area" id="node-details">
                <h3>Node Details</h3>
                <p>Click on a node in the graph above to see its output.</p>
                <pre id="node-output-pre">{}</pre>
            </div>

            <div class="final-output-area" id="final-output">
                <h3>Final Flipped Headline</h3>
                <p id="flipped-headline-text">Pending analysis...</p>
                <p id="db-save-status-text"></p>
            </div>
        </div>
    </div>

    <script>
        const headlineInput = document.getElementById('headline-input');
        const generateBtn = document.getElementById('generate-btn');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const statusMessage = document.getElementById('status-message');

        const graphVizArea = document.getElementById('graph-viz-area');
        const dynamicGraphFlowContainer = document.getElementById('dynamic-graph-flow');
        const nodeDetailsContainer = document.getElementById('node-details');
        const nodeOutputPre = document.getElementById('node-output-pre');
        
        const finalOutputArea = document.getElementById('final-output');
        const flippedHeadlineText = document.getElementById('flipped-headline-text');
        const dbSaveStatusText = document.getElementById('db-save-status-text');

        let currentGraphState = null;
        let currentGraphStructure = null;

        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') return '';
            return unsafe.toString()
                .replace(/&/g, "&") // Ensure & is escaped first
                .replace(/</g, "<")
                .replace(/>/g, ">")
                .replace(/"/g, "\"")
                .replace(/'/g, "'");
        }

        function showUIMessage(element, text, type = 'error') {
            element.textContent = text;
            element.className = `message ${type}`;
            element.style.display = 'block';
        }
        function hideUIMessages() {
            errorMessage.style.display = 'none';
            statusMessage.style.display = 'none';
        }

        generateBtn.addEventListener('click', async () => {
            const headline = headlineInput.value.trim();
            if (!headline) {
                showUIMessage(errorMessage, "Please enter a headline.");
                return;
            }

            hideUIMessages();
            loader.style.display = "block";
            generateBtn.disabled = true;
            graphVizArea.style.display = "none";
            dynamicGraphFlowContainer.innerHTML = ''; // Clear previous dynamic graph
            nodeOutputPre.textContent = "{}";
            nodeDetailsContainer.querySelector('h3').textContent = "Node Details";
            nodeDetailsContainer.querySelector('p').style.display = 'block';
            flippedHeadlineText.textContent = "Pending analysis...";
            dbSaveStatusText.textContent = "";
            

            try {
                const response = await fetch('/.netlify/functions/generate-frames', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ headline })
                });
                const responseData = await response.json();

                if (!response.ok) {
                    throw new Error(responseData.error || responseData.details || `Request failed: ${response.status}`);
                }
                
                currentGraphState = responseData.data;
                currentGraphStructure = responseData.graphStructure;

                let uiMessageType = 'success';
                if (currentGraphState && (
                    (currentGraphState.raw_analysis1 && currentGraphState.raw_analysis1.error) ||
                    (currentGraphState.raw_analysis2 && currentGraphState.raw_analysis2.error) ||
                    (currentGraphState.synthesis_details && currentGraphState.synthesis_details.error) ||
                    (currentGraphState.db_save_status && !currentGraphState.db_save_status.success)
                )) {
                    uiMessageType = 'warning';
                }
                showUIMessage(statusMessage, responseData.message || "Processing complete.", uiMessageType);

                if (currentGraphStructure && currentGraphState) {
                    renderGraphFlow(currentGraphStructure);
                    updateNodeStatusesAndFinalOutput(currentGraphStructure, currentGraphState);
                    graphVizArea.style.display = "block";
                } else {
                    console.warn("Graph structure or state not received from backend.");
                    dynamicGraphFlowContainer.innerHTML = '<p>Error: Graph structure or data not available.</p>';
                     graphVizArea.style.display = "block"; // Show the error message
                }

            } catch (error) {
                showUIMessage(errorMessage, `Error: ${error.message}`);
                console.error("Error during analysis:", error);
                currentGraphState = null;
                currentGraphStructure = null;
            } finally {
                loader.style.display = "none";
                generateBtn.disabled = false;
            }
        });
        
        function createNodeElement(id, displayName, detailsKey, statusKey) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'graph-node';
            nodeDiv.id = `node-${id}`; // Ensure unique DOM ID from structure
            nodeDiv.textContent = displayName;
            nodeDiv.dataset.detailsKey = detailsKey; 
            nodeDiv.dataset.statusKey = statusKey;   
            nodeDiv.dataset.nodeDisplayName = displayName; 
            return nodeDiv;
        }

        function attachNodeClickListeners() {
            const allGraphNodes = dynamicGraphFlowContainer.querySelectorAll('.graph-node');
            allGraphNodes.forEach(node => {
                node.addEventListener('click', () => {
                    if (!currentGraphState) return;

                    allGraphNodes.forEach(n => n.classList.remove('active'));
                    node.classList.add('active');
                    nodeDetailsContainer.querySelector('p').style.display = 'none';


                    const detailsKey = node.dataset.detailsKey;
                    const displayName = node.dataset.nodeDisplayName;
                    let detailsToShow = {};

                    if (detailsKey === "input_headline") { // Special case for input_headline string
                        detailsToShow = { "input_headline": currentGraphState.input_headline };
                    } else if (detailsKey && currentGraphState.hasOwnProperty(detailsKey)) {
                        detailsToShow = { [detailsKey]: currentGraphState[detailsKey] };
                    } else if (detailsKey) {
                        detailsToShow = { message: `No data available for ${displayName} (key: ${detailsKey}).` };
                    } else {
                        detailsToShow = { message: `No details key configured for ${displayName}.` };
                    }
                    
                    nodeOutputPre.textContent = JSON.stringify(detailsToShow, null, 2);
                    nodeDetailsContainer.querySelector('h3').textContent = `Details for: ${displayName}`;
                });
            });
        }

        function renderGraphFlow(structure) {
            dynamicGraphFlowContainer.innerHTML = ''; 

            if (!structure || !structure.nodes || structure.nodes.length === 0) {
                dynamicGraphFlowContainer.textContent = 'No graph structure to display.';
                return;
            }

            structure.nodes.forEach((stageInfo, index) => {
                const stageDiv = document.createElement('div');
                stageDiv.className = 'graph-stage';

                if (stageInfo.type === 'input') {
                    const nodeDiv = createNodeElement(stageInfo.id, stageInfo.displayName, stageInfo.detailsKey, stageInfo.statusKey);
                    stageDiv.appendChild(nodeDiv);
                } else if (stageInfo.type === 'parallel-group') {
                    stageDiv.classList.add('parallel-group-stage');
                    stageInfo.subNodes.forEach(subNodeInfo => {
                        const nodeDiv = createNodeElement(subNodeInfo.id, subNodeInfo.displayName, subNodeInfo.detailsKey, subNodeInfo.statusKey);
                        stageDiv.appendChild(nodeDiv);
                    });
                } else if (stageInfo.type === 'sequential') {
                    const nodeDiv = createNodeElement(stageInfo.id, stageInfo.displayName, stageInfo.detailsKey, stageInfo.statusKey);
                    stageDiv.appendChild(nodeDiv);
                }
                
                dynamicGraphFlowContainer.appendChild(stageDiv);

                if (index < structure.nodes.length - 1) {
                    const connectorDiv = document.createElement('div');
                    connectorDiv.className = 'node-connector';
                    if (stageInfo.type === 'parallel-group' && stageInfo.subNodes && stageInfo.subNodes.length > 1) {
                        connectorDiv.innerHTML = '<div>↓ ↓</div>'; 
                    } else {
                        connectorDiv.innerHTML = '↓';
                    }
                    dynamicGraphFlowContainer.appendChild(connectorDiv);
                }
            });
            attachNodeClickListeners();
        }

        function updateNodeStatusesAndFinalOutput(structure, graphData) {
            if (!structure || !structure.nodes || !graphData) return;

            // Update final output area
            flippedHeadlineText.textContent = escapeHtml(graphData.flipped_headline || "N/A");
            if (graphData.db_save_status) {
                dbSaveStatusText.textContent = graphData.db_save_status.success 
                    ? `Database: Saved successfully.`
                    : `Database: Save failed. ${escapeHtml(graphData.db_save_status.message || '')}`;
                dbSaveStatusText.style.color = graphData.db_save_status.success ? 'green' : 'red';
            } else {
                dbSaveStatusText.textContent = "Database: Status N/A";
                 dbSaveStatusText.style.color = 'inherit';
            }

            // Update node statuses
            structure.nodes.forEach(stageInfo => {
                const processNode = (nodeInfo) => {
                    const nodeEl = document.getElementById(`node-${nodeInfo.id}`);
                    if (!nodeEl) {
                        console.warn(`Node element 'node-${nodeInfo.id}' not found in DOM.`);
                        return;
                    }
                    nodeEl.classList.remove('success-node', 'error-node'); // Reset classes

                    const statusData = graphData[nodeInfo.statusKey];

                    if (nodeInfo.type === 'input') { // 'input' is a type of stageInfo, not nodeInfo here
                         if (graphData.hasOwnProperty(nodeInfo.statusKey) && graphData[nodeInfo.statusKey]) {
                            nodeEl.classList.add('success-node');
                        } else {
                            nodeEl.classList.add('error-node');
                        }
                    } else if (statusData) {
                        if (nodeInfo.statusKey === 'db_save_status') { // Special handling for db_save_status
                            if (statusData.success) nodeEl.classList.add('success-node');
                            else nodeEl.classList.add('error-node');
                        } else if (statusData.error) { // Standard error check for other nodes
                            nodeEl.classList.add('error-node');
                        } else {
                            nodeEl.classList.add('success-node');
                        }
                    } else {
                        nodeEl.classList.add('error-node'); // Data for status key missing, assume error
                    }
                };
                
                if (stageInfo.type === 'input' || stageInfo.type === 'sequential') {
                    processNode(stageInfo); // Stage info itself is the node info
                } else if (stageInfo.type === 'parallel-group') {
                    stageInfo.subNodes.forEach(subNodeInfo => {
                        processNode(subNodeInfo);
                    });
                }
            });

            // Click the first displayable node by default
            let firstNodeElementId = null;
            if (structure.nodes.length > 0) {
                const firstStage = structure.nodes[0];
                if (firstStage.type === 'input' || firstStage.type === 'sequential') {
                    firstNodeElementId = `node-${firstStage.id}`;
                } else if (firstStage.type === 'parallel-group' && firstStage.subNodes && firstStage.subNodes.length > 0) {
                    firstNodeElementId = `node-${firstStage.subNodes[0].id}`;
                }
            }
            if (firstNodeElementId) {
                const firstNodeToClick = document.getElementById(firstNodeElementId);
                if (firstNodeToClick) {
                    firstNodeToClick.click();
                }
            }
        }
        hideUIMessages(); // Initial hide
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph News Frames Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f4f7f6;
        }

        .container {
            background-color: white;
            border-radius: 10px;
            padding: 20px 30px; /* Adjusted padding */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        h1, h2 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }

        .input-area {
            margin-bottom: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        textarea {
            width: 95%;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
            min-height: 60px;
            margin-bottom: 15px;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1.5s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .message {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .error { color: #c0392b; background-color: #f9eaea; border: 1px solid #e74c3c; }
        .success { color: #27ae60; background-color: #eafaf1; border: 1px solid #a9dfbf; }

        /* Graph Visualization */
        .graph-visualization-area {
            margin-top: 30px;
            display: none; /* Hidden initially */
        }

        .graph-flow {
            display: flex;
            justify-content: space-around; /* Adjust as needed */
            align-items: flex-start; /* Align items at the top */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            margin-bottom: 20px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }

        .graph-node {
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            min-width: 150px; /* Ensure nodes have some width */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .graph-node:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .graph-node.active {
            border-color: #3498db;
            background-color: #ddeeff;
            font-weight: bold;
        }
        .graph-node.error-node { border-left: 5px solid #e74c3c; background-color: #fcefee; }
        .graph-node.success-node { border-left: 5px solid #2ecc71; background-color: #e6f7f0; }

        .node-connector { /* Simple visual cue, not a real line */
            align-self: center;
            font-size: 1.5em;
            color: #adb5bd;
            padding: 0 5px;
        }


        .node-details-area {
            margin-top: 20px;
            padding: 20px;
            background-color: #fdfefe;
            border: 1px solid #ecf0f1;
            border-radius: 8px;
            min-height: 100px;
        }
        .node-details-area h3 { text-align: left; margin-top: 0;}
        .node-details-area pre {
            background-color: #2c3e50; /* Dark background for code */
            color: #f8f9fa; /* Light text */
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 0.9em;
            white-space: pre-wrap; /* Allow wrapping */
            word-wrap: break-word; /* Break long words */
        }

        .final-output-area {
            margin-top: 30px;
            padding: 20px;
            background-color: #e6f7ff; /* Light blue background */
            border: 1px solid #aed6f1;
            border-radius: 8px;
            text-align: center;
        }
        .final-output-area h3 { color: #1f618d; }
        .final-output-area p { font-size: 1.1em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>LangGraph News Frames Visualizer</h1>

        <div class="input-area">
            <textarea id="headline-input" placeholder="Enter a news headline here..." rows="3"></textarea>
            <button id="generate-btn">Analyze with LangGraph</button>
        </div>

        <div id="loader" class="loader"></div>
        <div id="error-message" class="message error"></div>
        <div id="status-message" class="message"></div> <!-- For general status/success -->

        <div class="graph-visualization-area" id="graph-viz-area">
            <h2>Graph Execution Flow</h2>
            <div class="graph-flow">
                <div class="graph-node" data-node-key="input_headline" id="node-input">Input Headline</div>
                <span class="node-connector">→</span>
                <div class="graph-node" data-node-key="parallel_analyzers" id="node-analyzers">1. Parallel Analyzers</div>
                <span class="node-connector">→</span>
                <div class="graph-node" data-node-key="synthesizer" id="node-synthesizer">2. Synthesizer</div>
                <span class="node-connector">→</span>
                <div class="graph-node" data-node-key="saver" id="node-saver">3. Save to DB</div>
            </div>

            <div class="node-details-area" id="node-details">
                <h3>Node Details</h3>
                <p>Click on a node in the graph above to see its output.</p>
                <pre id="node-output-pre">{}</pre>
            </div>

            <div class="final-output-area" id="final-output">
                <h3>Final Flipped Headline</h3>
                <p id="flipped-headline-text">Pending analysis...</p>
                <p id="db-save-status-text"></p>
            </div>
        </div>
    </div>

    <script>
        const headlineInput = document.getElementById('headline-input');
        const generateBtn = document.getElementById('generate-btn');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('error-message');
        const statusMessage = document.getElementById('status-message');

        const graphVizArea = document.getElementById('graph-viz-area');
        const graphNodes = document.querySelectorAll('.graph-node');
        const nodeDetailsContainer = document.getElementById('node-details');
        const nodeOutputPre = document.getElementById('node-output-pre');
        
        const finalOutputArea = document.getElementById('final-output');
        const flippedHeadlineText = document.getElementById('flipped-headline-text');
        const dbSaveStatusText = document.getElementById('db-save-status-text');

        let currentGraphState = null; // To store the full graph_output

        // --- Helper Functions ---
        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') return '';
            return unsafe.toString()
                .replace(/&/g, "&")
                .replace(/</g, "<")
                .replace(/>/g, ">")
                .replace(/"/g, "\"")
                .replace(/'/g, "'");
        }

        function showUIMessage(element, text, type = 'error') {
            element.textContent = text;
            element.className = `message ${type}`;
            element.style.display = 'block';
        }
        function hideUIMessages() {
            errorMessage.style.display = 'none';
            statusMessage.style.display = 'none';
        }

        // --- Event Listeners ---
        generateBtn.addEventListener('click', async () => {
            const headline = headlineInput.value.trim();
            if (!headline) {
                showUIMessage(errorMessage, "Please enter a headline.");
                return;
            }

            hideUIMessages();
            loader.style.display = "block";
            generateBtn.disabled = true;
            graphVizArea.style.display = "none"; // Hide old viz
            nodeOutputPre.textContent = "{}"; // Reset details
            flippedHeadlineText.textContent = "Pending analysis...";
            dbSaveStatusText.textContent = "";
            graphNodes.forEach(n => n.classList.remove('active', 'error-node', 'success-node'));


            try {
                const response = await fetch('/.netlify/functions/generate-frames', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ headline })
                });

                const responseData = await response.json();

                if (!response.ok) {
                    throw new Error(responseData.error || responseData.message || `Request failed: ${response.status}`);
                }
                
                if (responseData.error_summary || (responseData.graph_output && Object.values(responseData.graph_output).some(v => v && v.error))) {
                    showUIMessage(statusMessage, responseData.message || "Processing completed with some issues.", "warning");
                } else {
                    showUIMessage(statusMessage, responseData.message || "Processing successful!", "success");
                }

                currentGraphState = responseData.graph_output;
                displayGraphResults(currentGraphState);
                graphVizArea.style.display = "block";

            } catch (error) {
                showUIMessage(errorMessage, `Error: ${error.message}`);
                console.error("Error during analysis:", error);
                currentGraphState = null; // Clear state on error
            } finally {
                loader.style.display = "none";
                generateBtn.disabled = false;
            }
        });

        graphNodes.forEach(node => {
            node.addEventListener('click', () => {
                if (!currentGraphState) return;

                graphNodes.forEach(n => n.classList.remove('active'));
                node.classList.add('active');

                const nodeKey = node.dataset.nodeKey;
                let detailsToShow = {};

                // The state keys are: input_headline, analysis1_result, analysis2_result, synthesis_result, flipped_headline, db_save_status
                // Map graph node clicks to the relevant parts of the state
                switch(nodeKey) {
                    case 'input_headline':
                        detailsToShow = { input_headline: currentGraphState.input_headline };
                        break;
                    case 'parallel_analyzers':
                        // Show both analysis1_result and analysis2_result as they are outputs of this conceptual step
                        detailsToShow = {
                            analysis1_result: currentGraphState.analysis1_result,
                            analysis2_result: currentGraphState.analysis2_result
                        };
                        break;
                    case 'synthesizer':
                        detailsToShow = { synthesis_result: currentGraphState.synthesis_result };
                        break;
                    case 'saver':
                        detailsToShow = { db_save_status: currentGraphState.db_save_status };
                        break;
                    default:
                        detailsToShow = { message: "No specific data for this conceptual node." };
                }
                nodeOutputPre.textContent = JSON.stringify(detailsToShow, null, 2);
                nodeDetailsContainer.querySelector('h3').textContent = `Details for: ${node.textContent}`;
            });
        });

        // --- Display Logic ---
        function displayGraphResults(graphData) {
            if (!graphData) return;

            // Update final flipped headline and DB status
            flippedHeadlineText.textContent = escapeHtml(graphData.flipped_headline || "N/A");
            if (graphData.db_save_status) {
                dbSaveStatusText.textContent = graphData.db_save_status.success 
                    ? `Database: Saved successfully.`
                    : `Database: Save failed. ${escapeHtml(graphData.db_save_status.message || '')}`;
                dbSaveStatusText.style.color = graphData.db_save_status.success ? 'green' : 'red';
            } else {
                dbSaveStatusText.textContent = "Database: Status N/A";
            }

            // Visually update nodes based on success/error (simplified)
            // Input node is always "success" if we reached here
            document.getElementById('node-input').classList.add('success-node');

            // Parallel Analyzers (conceptual node)
            const analyzersNode = document.getElementById('node-analyzers');
            if (graphData.analysis1_result?.error || graphData.analysis2_result?.error) {
                analyzersNode.classList.add('error-node');
            } else if (graphData.analysis1_result || graphData.analysis2_result) {
                analyzersNode.classList.add('success-node');
            }

            // Synthesizer Node
            const synthesizerNode = document.getElementById('node-synthesizer');
            if (graphData.synthesis_result?.error) {
                synthesizerNode.classList.add('error-node');
            } else if (graphData.synthesis_result) {
                synthesizerNode.classList.add('success-node');
            }
            
            // Saver Node
            const saverNode = document.getElementById('node-saver');
            if (graphData.db_save_status && !graphData.db_save_status.success) {
                saverNode.classList.add('error-node');
            } else if (graphData.db_save_status && graphData.db_save_status.success) {
                saverNode.classList.add('success-node');
            }

            // Automatically click the input node to show initial details
            document.getElementById('node-input').click();
        }

    </script>
</body>
</html>
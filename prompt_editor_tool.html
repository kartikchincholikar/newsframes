<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph.js Analyzer Editor</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --card-bg: #2a2a2a;
            --input-bg: #3c3c3c;
            --text-color: #d4d4d4;
            --primary-color: #0e639c;
            --primary-hover: #1177bb;
            --danger-color: #b83232;
            --danger-hover: #d33a3a;
            --border-color: #4a4a4a;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --header-font: "Segoe UI", "Trebuchet MS", sans-serif;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: auto;
        }
        h1 {
            font-family: var(--header-font);
            color: var(--text-color);
            text-align: center;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        .controls > div {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }
        .btn-add {
            background-color: var(--primary-color);
        }
        .btn-add:hover {
            background-color: var(--primary-hover);
        }
        .btn-download {
            background-color: #2a9d8f;
        }
        .btn-download:hover {
            background-color: #2ec4b6;
        }
        .btn-load { /* New Style for Load Button */
            background-color: #6a6a6a;
        }
        .btn-load:hover {
            background-color: #7c7c7c;
        }
        .task-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .task-header {
            background-color: rgba(0,0,0,0.2);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .task-header h2 {
            margin: 0;
            font-size: 1.2em;
        }
        .task-header h2 .arrow {
            display: inline-block;
            transition: transform 0.2s;
        }
        .task-body {
            padding: 20px;
            display: none; /* Collapsed by default */
        }
        .task-card.expanded .task-body {
            display: block;
        }
        .task-card.expanded .arrow {
            transform: rotate(90deg);
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #a0a0a0;
        }
        input[type="text"], textarea {
            width: 100%;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
            font-size: 14px;
            font-family: inherit;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        .btn-delete {
            background-color: var(--danger-color);
        }
        .btn-delete:hover {
            background-color: var(--danger-hover);
        }
        .examples-section {
            border-top: 2px solid var(--border-color);
            margin-top: 20px;
            padding-top: 20px;
        }
        .example-card {
            border: 1px dashed var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            position: relative;
        }
        .btn-delete-example {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
            padding: 3px 8px;
            font-size: 12px;
        }
        .btn-delete-example:hover {
            background-color: var(--danger-color);
            color: white;
        }
        .btn-add-example {
            background-color: #4a4a4a;
            margin-top: 15px;
        }
        .btn-add-example:hover {
            background-color: #5a5a5a;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>LangGraph.js Analyzer Editor</h1>

        <div class="controls">
            <button id="addNewTaskBtn" class="btn-add">Add New Analyzer Task</button>
            <div>
                <button id="loadJsonBtn" class="btn-load">Load Config</button>
                <button id="downloadJsonBtn" class="btn-download">Download Updated JSON</button>
            </div>
        </div>

        <div id="tasks-container">
            <!-- Analyzer task cards will be dynamically inserted here -->
        </div>
    </div>
    
    <!-- Hidden file input for loading JSON files -->
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
    // The initial JSON configuration provided by the user
    const initialConfig = {
      "entryPointNodeId": "properNoun_replacer1",
      "nodeDefinitions": [
        {
          "id": "properNoun_replacer1",
          "displayName": "0. Proper Noun Replacer (Initial)",
          "type": "llm_agent",
          "stateInputArgs": {
            "headline": "input_headline"
          },
          "stateOutputKey": "properNoun_replacement1_result",
          "derivedStateOutputs": {
            "headline_with_placeholders": {
              "path": "text_with_placeholders",
              "fallbackKey": "input_headline"
            },
            "properNoun_map": {
              "path": "properNoun_map",
              "fallbackValue": {}
            }
          },
          "promptConfig": {
            "systemMessage": "You are an AI assistant. Your task is to replace proper nouns in the given text with unique, bracketed, uppercase placeholders (e.g., [PERSON_A], [THING_B], [LOCATION_C]). Identify the original proper nouns and the placeholders you created. Output ONLY valid JSON as specified, without any markdown or other text outside the JSON structure.",
            "developerInstructionsTemplate": "Instruction:\n1. Analyze the input text: \"{{headline}}\".\n2. Identify all proper nouns.\n3. For each identified proper noun, create a unique placeholder (e.g., [PERSON_A], [PERSON_B], [OBJECT_A], [GROUP_A]).\n4. Replace the proper nouns in the text with these placeholders.\n5. Provide a mapping of each placeholder to its original proper noun.\nYour entire output MUST be a single, valid JSON object.\n\nRequired JSON Output Schema:\n{\n  \"original_text\": \"The original input text, which is '{{headline}}'\",\n  \"text_with_placeholders\": \"The text with properNouns replaced by placeholders\",\n  \"properNoun_map\": {\n    \"[PLACEHOLDER_A]\": \"original_properNoun_A\",\n    \"[PLACEHOLDER_B]\": \"original_properNoun_B\"\n  }\n}\n\nExample:\nInput Text: \"Satya Nadella visited London.\"\nOutput:\n{\n  \"original_text\": \"Satya Nadella visited London.\",\n  \"text_with_placeholders\": \"[PERSON_A] visited [LOCATION_A].\",\n  \"properNoun_map\": {\n    \"[PERSON_A]\": \"Satya Nadella\",\n    \"[LOCATION_A]\": \"London\"\n  }\n}",
            "userInputTemplate": "Process this text: \"{{headline}}\""
          }
        },
        {
          "id": "parallel_analyzers_coordinator",
          "displayName": "1. Parallel Analyzers",
          "type": "parallel_llm_group_coordinator",
          "stateInputArgs": {
            "headline_with_placeholders": "headline_with_placeholders",
            "input_headline": "input_headline"
          },
          "analyzerTasks": [
            {
              "id": "cognitive_frames_analyzer",
              "displayName": "1a. Cognitive Frames Analysis & Flip",
              "stateOutputKey": "cognitive_frames_analysis_result",
              "promptConfig": {
                "systemMessage": "You are an expert in Journalism and Media Studies specializing in cognitive frame analysis. Your job is to study news headlines (which may contain placeholders like [PERSON_A]) to identify embedded cognitive frames AND to attempt to rewrite the headline by emphasizing an alternative or opposing frame. Output ONLY valid JSON as specified.",
                "developerInstructionsTemplate": "Instruction:\n1. Carefully parse and analyze keywords, linguistic indicators, agent/patient roles, and contextual elements the input headline: \"{{headlineToAnalyze}}\".\n2. Identify relevant cognitive frames (e.g., Conflict, Human Interest, Responsibility, Economic Consequences, Morality, Progress/Recovery).\n3. Based on your analysis, select a dominant frame and then rewrite the headline to emphasize an alternative or opposing cognitive frame while preserving the core facts from the original headline. Retain the placeholders in the input headline.                                                                                                                                            \n4. Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: \"[COMPANY_A] announces record profits amidst layoffs, citing efficiency gains.\"\nOutput:\n{\n  \"input_headline\": \"[COMPANY_A] announces record profits amidst layoffs, citing efficiency gains.\",\n  \"analysis\": \"[Write analysis here]\", \n  \"rewritten_headline\": \"Despite [COMPANY_A]'s record profits, workers face job losses as company prioritizes 'efficiency'.\"\n}",
                "userInputTemplate": "Input: \"{{headlineToAnalyze}}\""
              }
            },
            {
              "id": "speculative_reframing_analyzer",
              "displayName": "1b. Speculative Reframing",
              "stateOutputKey": "speculative_reframing_result",
              "promptConfig": {
                "systemMessage": "You are an expert in Journalism and Media Studies. You specialize in rewriting news headlines with additional plausible, but unlikely, speculative information, inspired by Russell's Teapot. Write clearly and plausibly. Respond ONLY in valid JSON format as specified.",
                "developerInstructionsTemplate": "Instruction:\n1. Carefully parse and analyze keywords, linguistic indicators, agent/patient roles, and contextual elements the input headline: \"{{headlineToAnalyze}}\".\n2. Understand the headline, the agent/patient roles, verbs, and study the message being conveyed to the audience.                          \n3. Rewrite the headline by adding extra speculative information, speculative explainations and backstories. This additions could be physically plausible, but should be unlikely. The additions can by jocular, dodgy, blimey, serious, devastating, mysterious, clickbaity and not necessarily paranoid. Place these speculative additon in parentheses. Retain the placeholders in the input headline.\n4  Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: \"Dog attacks 4-year-old causing injuries\"\nOutput:\n{\n  \"input_headline\": \"Dog attacks 4-year-old causing injuries\",\n  \"analysis\": \"[Write analysis here]\", \n  \"rewritten_headline\": \"Dog attacks 4-year-old causing injuries (perhaps because the child had been unknowingly tormenting the dog's hidden puppies for weeks)\"\n}",
                "userInputTemplate": "Input: \"{{headlineToAnalyze}}\""
              }
            },
            {
              "id": "euphemism_analyzer",
              "displayName": "1c. Euphemism Analysis & Literal Flip",
              "stateOutputKey": "euphemism_analysis_result",
              "promptConfig": {
                "systemMessage": "You are an expert in Journalism and Media Studies. Your job is to study news headlines (which may contain placeholders like [PERSON_A]) to detect euphemisms, explain their impact, AND rewrite the headline using direct, literal language. Output ONLY valid JSON as specified.",
                "developerInstructionsTemplate": "Instruction:\n1. Carefully parse and analyze keywords, linguistic indicators, agent/patient roles, and contextual elements the input headline: \"{{headlineToAnalyze}}\".\n2. Detect euphemistic, diplomatic terms or phrases, which downplay, white wash or use Colonial Administrative Language in the headline .   \n3. For each identified euphemistic, diplomatic, or Colonial Administrative term analyze what is being downplayed or minimized. Place any additional information added in parentheses. Rewrite the entire headline by replacing all impactful euphemisms with their direct, literal crude meanings. Retain the placeholders in the input headline.          \n4. Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: \"[MILITARY_UNIT] neutralized targets in [AREA_X] during a security operation.\"\nOutput:\n{\n  \"input_headline\": \"[MILITARY_UNIT] neutralized targets in [AREA_X] during a security operation.\",\n  \"analysis\": \"[Write analysis here]\",\n  \"rewritten_headline\": \"[MILITARY_UNIT] killed people or destroyed objectives in [AREA_X] during a military offensive.\"\n}",
                "userInputTemplate": "Input: \"{{headlineToAnalyze}}\""
              }
            },
            {
              "id": "episodic_thematic_analyzer",
              "displayName": "1d. episodic_thematic Analysis (Episodic/Thematic)",
              "stateOutputKey": "episodic_thematic_analysis_result",
              "promptConfig": {
                "systemMessage": "You are an expert in media framing analysis. Analyze news snippets to identify whether they use episodic or thematic framing and suggest a reframing that might include placeholders. Output ONLY valid JSON as specified.",
                "developerInstructionsTemplate": "Instruction:\n1. Carefully parse and analyze keywords, linguistic indicators, agent/patient roles, and contextual elements the input headline: \"{{headlineToAnalyze}}\".\n2. Determine if the headline uses thematic or episodic news framing to get a point accross.                                                \n3. If thematic framing is detected, convert it and rewrite the headline using episodic framing. If episodic framing is detected, convert it and rewrite the headline using thematic framing. Place any additional information added in parentheses. Retain the placeholders in the input headline.                                                                                                      \n4. Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: \"In [CITY_A], a 1-year-old boy died from complications of malnutrition.\"\nOutput:\n{\n  \"input_headline\": \"In [CITY_A], a 1-year-old boy died from complications of malnutrition.\",\n  \"analysis\": \"[Write analysis here]\", \n  \"rewritten_headline\": \"Widespread malnutrition, exacerbated by drought and aid shortages in places like [CITY_A], continues to claim young lives across the Horn of Africa, highlighting a systemic crisis.\"\n}",
                "userInputTemplate": "Input: \"{{headlineToAnalyze}}\""
              }
            },
            {
              "id": "violence_type_analyzer",
              "displayName": "1e. Violence Type Analysis & Systemic Link",
              "stateOutputKey": "violence_type_analysis_result",
              "promptConfig": {
                "systemMessage": "You are an expert in media news framing. Your job is analyze a headline contains spectacular violence (sudden, dramatic harm such as attacks, riots, murders). If spectacular violence IS found, you will speculate a plausible underlying systemic/structural cause and rewrite the headline appending this cause in parentheses. Output ONLY valid JSON as specified.",
                "developerInstructionsTemplate": "Instruction:\n1. Carefully parse and analyze keywords, linguistic indicators, agent/patient roles, and contextual elements the input headline: \"{{headlineToAnalyze}}\".\n2. Determine if the headlines contains spectacular violence (sudden, dramatic harm such as attacks, riots, murders).                       \n3. If spectacular violence is found, you will speculate a plausible underlying systemic/structural cause and rewrite the headline appending this cause in parentheses. If spectacular violence is not found: Indicate this clearly in the output. Retain the placeholders in the input headline.                                                                                                        \n4. Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: \"Rioters smash downtown storefronts in [CITY_B].\"\nOutput:\n{\n  \"input_headline\": \"Rioters smash downtown storefronts in [CITY_B].\",\n  \"analysis\": \"[Write analysis here]\", \n  \"rewritten_headline\": \"Rioters smash downtown storefronts in [CITY_B] (amid rising youth unemployment and a lack of community services).\"\n}",
                "userInputTemplate": "Input: \"{{headlineToAnalyze}}\""
              }
            }
          ]
        },
        {
          "id": "speculative_reverter",
          "displayName": "Revert Speculative Headline",
          "type": "local_function",
          "functionName": "revertGenericAnalyzerHeadline",
          "stateInputArgs": {
            "analyzer_result_object": "speculative_reframing_result",
            "properNoun_map": "properNoun_map"
          },
          "stateOutputKey": "speculative_reverted_headline"
        },
        {
          "id": "episodic_thematic_reverter",
          "displayName": "Revert episodic_thematic Suggestion",
          "type": "local_function",
          "functionName": "revertGenericAnalyzerHeadline",
          "stateInputArgs": {
            "analyzer_result_object": "episodic_thematic_analysis_result",
            "properNoun_map": "properNoun_map"
          },
          "stateOutputKey": "episodic_thematic_reverted_headline"
        },
        {
          "id": "violence_type_reverter",
          "displayName": "Revert Violence Type Headline",
          "type": "local_function",
          "functionName": "revertGenericAnalyzerHeadline",
          "stateInputArgs": {
            "analyzer_result_object": "violence_type_analysis_result",
            "properNoun_map": "properNoun_map"
          },
          "stateOutputKey": "violence_type_reverted_headline"
        },
        {
          "id": "cognitive_frames_reverter",
          "displayName": "Revert Cognitive Type Headline",
          "type": "local_function",
          "functionName": "revertGenericAnalyzerHeadline",
          "stateInputArgs": {
            "analyzer_result_object": "cognitive_frames_analysis_result",
            "properNoun_map": "properNoun_map"
          },
          "stateOutputKey": "cognitive_frames_reverted_headline"
        },
        {
          "id": "euphemism_reverter",
          "displayName": "Revert Euphemism Type Headline",
          "type": "local_function",
          "functionName": "revertGenericAnalyzerHeadline",
          "stateInputArgs": {
            "analyzer_result_object": "euphemism_analysis_result",
            "properNoun_map": "properNoun_map"
          },
          "stateOutputKey": "euphemism_reverted_headline"
        },
        {
          "id": "synthesizer",
          "displayName": "2. Synthesizer (Main Flip)",
          "type": "llm_agent",
          "stateInputArgs": {
            "headlineToSynthesize": "headlineToAnalyze",
            "analysis1": "cognitive_frames_analysis_result",
            "analysis2": "speculative_reframing_result",
            "analysis3": "euphemism_analysis_result",
            "analysis4": "episodic_thematic_analysis_result",
            "analysis5": "violence_type_analysis_result"
          },
          "stateOutputKey": "synthesis_result",
          "derivedStateOutputs": {
            "main_flipped_headline_with_placeholders": {
              "path": "flipped_headline",
              "fallbackValue": "Main alternative perspective unavailable (synthesis error or not found)"
            }
          },
          "promptConfig": {
            "systemMessage": "You are an expert in Journalism and Media Studies specializing in news framing. Your task is to generate a 'flipped_headline' that conveys the SAME CORE FACTS from the original headline but with an opposite (flipped) news framing, based on the provided analyses. Output ONLY valid JSON as specified.",
            "developerInstructionsTemplate": "Instruction:\n1. Study the original headline: \"{{headlineToSynthesize}}\".\n2. Review the provided analyses:\n   - Cognitive News Framing: {{analysis1}}\n   - Speculative News Framing : {{analysis2}}\n   - Euphemistic News Framing: {{analysis3}}\n   - Episodic/Thematic News Framing: {{analysis4}}\n   - Spectacular/Systemic Violence News Framing: {{analysis5}}\n3. Based on these, choose one or more analyses that provide strong evidence of a particular news frame in the original headline.\n4. Generate a \"flipped_headline\" that reverses or significantly alters this news framing while ATTEMPTING TO PRESERVE THE CORE FACTUAL INFORMATION.\n5. The flipped headline should ideally use the same placeholders if they were present in \"{{headlineToSynthesize}}\".\nYour entire output MUST be a single, valid JSON object.\n\nRequired JSON Output Schema:\n{\n  \"input_headline_processed\": \"{{headlineToSynthesize}}\",\n  \"flipped_headline\": \"string (The new headline with flipped framing, may contain placeholders)\",\n  \"reasoning_for_flip\": \"string (Brief explanation of which analysis inspired the flip and how the frame was altered)\",\n  \"analysis_summary_used\": { \n      \"cognitive_frames_had_error\": {{analysis1.error ? true : false}},\n      \"speculative_reframing_had_error\": {{analysis2.error ? true : false}},\n      \"euphemism_analysis_had_error\": {{analysis3.error ? true : false}},\n      \"episodic_thematic_analysis_had_error\": {{analysis4.error ? true : false}},\n      \"violence_type_analysis_had_error\": {{analysis5.error ? true : false}}\n  }\n}\nExample:\nInput Headline: \"[LEADER_X] announces decisive action against protest.\"\nCognitive Frame Analysis might indicate \"Control/Order\" frame.\nFlipped Headline might be: \"Community members express concerns as [LEADER_X] escalates measures against public assembly.\"\n\nOutput:\n{\n  \"input_headline_processed\": \"[LEADER_X] announces decisive action against protest.\",\n  \"flipped_headline\": \"Community members express concerns as [LEADER_X] escalates measures against public assembly.\",\n  \"reasoning_for_flip\": \"Flipped from a 'Control/Order' frame implied by 'decisive action' to a 'Concern/Rights' frame by focusing on community perspective and 'escalates measures'.\",\n  \"analysis_summary_used\": { \"cognitive_frames_had_error\": false, \"speculative_reframing_had_error\": false, \"euphemism_analysis_had_error\": false, \"episodic_thematic_analysis_had_error\": false, \"violence_type_analysis_had_error\": false }\n}",
            "userInputTemplate": "Synthesize a flipped headline for: \"{{headlineToSynthesize}}\" using the provided analyses."
          }
        },
        {
          "id": "main_headline_reverter",
          "displayName": "3. Revert Main Flipped Headline",
          "type": "local_function",
          "functionName": "revertProperNouns",
          "stateInputArgs": {
            "text_with_placeholders": "main_flipped_headline_with_placeholders",
            "properNoun_map": "properNoun_map"
          }
        },
        {
          "id": "data_collector_for_saver",
          "displayName": "Collect Data for Saver",
          "type": "local_function",
          "functionName": "collectAndVerifyDataForSaver",
          "stateInputArgs": {
            "input_headline": "input_headline",
            "main_flipped_headline_from_state": "flipped_headline",
            "speculative_reverted_headline": "speculative_reverted_headline",
            "episodic_thematic_reverted_headline": "episodic_thematic_reverted_headline",
            "violence_type_reverted_headline": "violence_type_reverted_headline",
            "cognitive_frames_reverted_headline": "cognitive_frames_reverted_headline",
            "euphemism_reverted_headline": "euphemism_reverted_headline"
          },
          "stateOutputKey": "data_package_for_saver"
        },
        {
          "id": "saver",
          "displayName": "4. Save All to DB",
          "type": "local_function",
          "functionName": "saveAllToDynamoDB",
          "stateInputArgs": {
            "packaged_data": "data_package_for_saver"
          },
          "stateOutputKey": "db_save_status"
        }
      ],
      "graphEdges": [
        { "source": "properNoun_replacer1", "target": "parallel_analyzers_coordinator" },
        { "source": "parallel_analyzers_coordinator", "target": "cognitive_frames_reverter" },
        { "source": "parallel_analyzers_coordinator", "target": "euphemism_reverter" },
        { "source": "parallel_analyzers_coordinator", "target": "speculative_reverter" },
        { "source": "parallel_analyzers_coordinator", "target": "episodic_thematic_reverter" },
        { "source": "parallel_analyzers_coordinator", "target": "violence_type_reverter" },
        { "source": "parallel_analyzers_coordinator", "target": "synthesizer" },
        { "source": "synthesizer", "target": "main_headline_reverter" },
        { "source": "main_headline_reverter", "target": "data_collector_for_saver" },
        { "source": "cognitive_frames_reverter", "target": "data_collector_for_saver" },
        { "source": "euphemism_reverter", "target": "data_collector_for_saver" },
        { "source": "speculative_reverter", "target": "data_collector_for_saver" },
        { "source": "episodic_thematic_reverter", "target": "data_collector_for_saver" },
        { "source": "violence_type_reverter", "target": "data_collector_for_saver" },
        { "source": "data_collector_for_saver", "target": "saver" },
        { "source": "saver", "target": "END" }
      ]
    };
    
    // In-memory state of the configuration
    let configData;

    document.addEventListener('DOMContentLoaded', () => {
        // Deep copy to avoid modifying the original constant object
        configData = JSON.parse(JSON.stringify(initialConfig));
        renderAnalyzerTasks();

        // Attach event listeners
        document.getElementById('addNewTaskBtn').addEventListener('click', addNewTask);
        document.getElementById('downloadJsonBtn').addEventListener('click', downloadJson);
        
        // --- NEW: Load functionality listeners ---
        document.getElementById('loadJsonBtn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        document.getElementById('file-input').addEventListener('change', handleFileLoad);
    });

    // --- NEW: File loading function ---
    function handleFileLoad(event) {
        const file = event.target.files[0];
        if (!file) {
            return; // User cancelled the dialog
        }

        const reader = new FileReader();

        reader.onload = function(e) {
            try {
                const newConfig = JSON.parse(e.target.result);

                // Basic validation: Check for essential top-level keys
                if (!newConfig.nodeDefinitions || !newConfig.graphEdges || !newConfig.entryPointNodeId) {
                    alert('Invalid configuration file. It appears to be missing required keys like "nodeDefinitions", "graphEdges", or "entryPointNodeId".');
                    return;
                }
                
                // More specific validation: Check if the parallel coordinator exists
                const parallelNode = newConfig.nodeDefinitions.find(n => n.id === 'parallel_analyzers_coordinator');
                if (!parallelNode || !Array.isArray(parallelNode.analyzerTasks)) {
                    alert('Invalid configuration file. Could not find the "parallel_analyzers_coordinator" node or its "analyzerTasks" array.');
                    return;
                }

                // If validation passes, update the global state
                configData = newConfig;
                
                // Re-render the entire UI with the new data
                renderAnalyzerTasks();
                
                alert('Configuration loaded successfully!');

            } catch (error) {
                console.error("Error parsing JSON file:", error);
                alert('Failed to load file. It might not be a valid JSON file.');
            } finally {
                // Reset the file input value. This allows reloading the same file.
                event.target.value = null;
            }
        };

        reader.onerror = function() {
            alert('An error occurred while reading the file.');
        };

        reader.readAsText(file);
    }

    function getAnalyzersNode() {
        // Handle case where configData might not be fully loaded or is invalid
        if (!configData || !configData.nodeDefinitions) {
            console.error("Config data is not initialized properly.");
            return null;
        }
        return configData.nodeDefinitions.find(n => n.id === 'parallel_analyzers_coordinator');
    }
    
    // --- Render Functions ---

    function renderAnalyzerTasks() {
        const container = document.getElementById('tasks-container');
        container.innerHTML = '';
        const analyzersNode = getAnalyzersNode();

        if (analyzersNode && analyzersNode.analyzerTasks) {
            analyzersNode.analyzerTasks.forEach((task, index) => {
                const taskCard = document.createElement('div');
                taskCard.className = 'task-card';
                taskCard.dataset.taskId = task.id;

                const { instructions, examples } = parseDeveloperInstructions(task.promptConfig.developerInstructionsTemplate);
                
                // Store parsed examples for easier updates
                task.parsedExamples = examples;
                task.instructionsText = instructions;

                taskCard.innerHTML = `
                    <div class="task-header">
                        <h2><span class="arrow">▶</span> ${task.displayName}</h2>
                        <button class="btn-delete" data-task-id="${task.id}">Delete Task</button>
                    </div>
                    <div class="task-body">
                        <div class="form-group">
                            <label for="displayName-${task.id}">Display Name</label>
                            <input type="text" id="displayName-${task.id}" value="${task.displayName}">
                        </div>
                        <div class="form-group">
                            <label for="systemMessage-${task.id}">System Message</label>
                            <textarea id="systemMessage-${task.id}">${task.promptConfig.systemMessage}</textarea>
                        </div>
                         <div class="form-group">
                            <label for="userInputTemplate-${task.id}">User Input Template</label>
                            <textarea id="userInputTemplate-${task.id}">${task.promptConfig.userInputTemplate}</textarea>
                        </div>
                        <div class="form-group">
                            <label for="instructions-${task.id}">Developer Instructions (text part)</label>
                            <textarea id="instructions-${task.id}">${instructions}</textarea>
                        </div>
                        <div class="examples-section">
                            <h3>Examples</h3>
                            <div id="examples-container-${task.id}"></div>
                            <button class="btn-add-example" data-task-id="${task.id}">Add Example</button>
                        </div>
                    </div>
                `;
                container.appendChild(taskCard);
                renderExamples(task.id, examples);
            });
        }
        addEventListeners();
    }

    function renderExamples(taskId, examples) {
        const container = document.getElementById(`examples-container-${taskId}`);
        container.innerHTML = '';
        examples.forEach((example, index) => {
            const exampleCard = document.createElement('div');
            exampleCard.className = 'example-card';
            exampleCard.dataset.exampleIndex = index;
            exampleCard.innerHTML = `
                <button class="btn-delete-example" data-task-id="${taskId}" data-example-index="${index}">×</button>
                <h4>Example ${index + 1}</h4>
                <div class="form-group">
                    <label>Input Headline</label>
                    <textarea class="example-input" data-field="input_headline">${example.input_headline || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Analysis</label>
                    <textarea class="example-input" data-field="analysis">${example.analysis || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Rewritten Headline</label>
                    <textarea class="example-input" data-field="rewritten_headline">${example.rewritten_headline || ''}</textarea>
                </div>
            `;
            container.appendChild(exampleCard);
        });
    }

    // --- Event Handlers & State Updaters ---

    function addEventListeners() {
        document.querySelectorAll('.task-header').forEach(header => {
            header.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') {
                    header.parentElement.classList.toggle('expanded');
                }
            });
        });

        document.querySelectorAll('.btn-delete').forEach(btn => {
            btn.addEventListener('click', () => deleteTask(btn.dataset.taskId));
        });

        document.querySelectorAll('.btn-add-example').forEach(btn => {
            btn.addEventListener('click', () => addExample(btn.dataset.taskId));
        });
        
        document.querySelectorAll('.btn-delete-example').forEach(btn => {
            btn.addEventListener('click', () => deleteExample(btn.dataset.taskId, parseInt(btn.dataset.exampleIndex, 10)));
        });

        // Update state on input change
        document.querySelectorAll('input[type="text"], textarea').forEach(input => {
            input.addEventListener('change', handleInputChange);
        });
    }

    function handleInputChange(event) {
        const input = event.target;
        const card = input.closest('.task-card');
        const taskId = card.dataset.taskId;
        const analyzersNode = getAnalyzersNode();
        if (!analyzersNode) return;
        const task = analyzersNode.analyzerTasks.find(t => t.id === taskId);
        
        if (input.classList.contains('example-input')) {
            const exampleCard = input.closest('.example-card');
            const exampleIndex = parseInt(exampleCard.dataset.exampleIndex, 10);
            const field = input.dataset.field;
            task.parsedExamples[exampleIndex][field] = input.value;
        } else {
            const fieldId = input.id.split('-')[0];
            switch (fieldId) {
                case 'displayName':
                    task.displayName = input.value;
                    // Also update the header in real-time
                    card.querySelector('.task-header h2').innerHTML = `<span class="arrow">▶</span> ${input.value}`;
                    break;
                case 'systemMessage':
                    task.promptConfig.systemMessage = input.value;
                    break;
                case 'userInputTemplate':
                    task.promptConfig.userInputTemplate = input.value;
                    break;
                case 'instructions':
                    task.instructionsText = input.value;
                    break;
            }
        }
    }

    function deleteTask(taskId) {
        if (!confirm(`Are you sure you want to delete the task with ID "${taskId}"? This will also remove its related nodes and edges.`)) {
            return;
        }
        const analyzersNode = getAnalyzersNode();
        if (!analyzersNode) return;
        analyzersNode.analyzerTasks = analyzersNode.analyzerTasks.filter(t => t.id !== taskId);
        renderAnalyzerTasks();
    }
    
    function addNewTask() {
        const analyzersNode = getAnalyzersNode();
        if (!analyzersNode) return;
        const newIdBase = `new_analyzer_${Date.now()}`;
        const newTask = {
            id: `${newIdBase}_analyzer`,
            displayName: "New Analyzer Task",
            stateOutputKey: `${newIdBase}_analysis_result`,
            promptConfig: {
                systemMessage: "You are an AI assistant. [Describe your role]. Output ONLY valid JSON as specified.",
                developerInstructionsTemplate: `Instruction:\n1. Analyze the input headline: "{{headlineToAnalyze}}".\n2. [Your instructions here]\n3. Your entire output MUST be a single, valid JSON object.\n\nExample 1:\nInput: "[SOME_ENTITY] does something."\nOutput:\n{\n  "input_headline": "[SOME_ENTITY] does something.",\n  "analysis": "[Write analysis here]",\n  "rewritten_headline": "[Rewritten headline here]"\n}`,
                userInputTemplate: "Input: \"{{headlineToAnalyze}}\""
            }
        };
        analyzersNode.analyzerTasks.push(newTask);
        renderAnalyzerTasks();
        // Expand the new card
        const newCard = document.querySelector(`.task-card[data-task-id="${newTask.id}"]`);
        if(newCard) newCard.classList.add('expanded');
    }

    function addExample(taskId) {
        const analyzersNode = getAnalyzersNode();
        if (!analyzersNode) return;
        const task = analyzersNode.analyzerTasks.find(t => t.id === taskId);
        const newExample = {
            input_headline: "",
            analysis: "",
            rewritten_headline: ""
        };
        task.parsedExamples.push(newExample);
        renderExamples(taskId, task.parsedExamples);
        addEventListeners(); // Re-attach listeners for new elements
    }

    function deleteExample(taskId, exampleIndex) {
         const analyzersNode = getAnalyzersNode();
         if (!analyzersNode) return;
         const task = analyzersNode.analyzerTasks.find(t => t.id === taskId);
         task.parsedExamples.splice(exampleIndex, 1);
         renderExamples(taskId, task.parsedExamples);
         addEventListeners(); // Re-attach listeners for new elements
    }
    
    // --- Parsing and Reconstruction ---

    function parseDeveloperInstructions(template) {
        const exampleRegex = /Example\s*\d+:\s*Input:[\s\S]*?Output:\s*(\{[\s\S]*?\})/g;
        let lastIndex = 0;
        const examples = [];
        let match;

        while ((match = exampleRegex.exec(template)) !== null) {
            try {
                // The JSON is in the first capturing group
                const exampleJson = JSON.parse(match[1]);
                examples.push(exampleJson);
            } catch (e) {
                console.error("Failed to parse example JSON:", e, match[1]);
                // Push a placeholder if parsing fails to maintain structure
                examples.push({ error: "Failed to parse", raw: match[1] });
            }
            lastIndex = match.index + match[0].length;
        }

        const instructions = template.substring(0, template.search(/Example\s*1:/) || template.length).trim();
        return { instructions, examples };
    }
    
    function reconstructDeveloperInstructions(task) {
        let result = task.instructionsText + '\n';
        task.parsedExamples.forEach((ex, index) => {
            // Find input and output parts to reconstruct the original format
            const inputHeadlineString = ex.input_headline;
            const outputJson = JSON.stringify({
                input_headline: ex.input_headline,
                analysis: ex.analysis,
                rewritten_headline: ex.rewritten_headline
            }, null, 2);
            result += `\nExample ${index + 1}:\nInput: "${inputHeadlineString}"\nOutput:\n${outputJson}`;
        });
        return result.trim();
    }
    
    // --- Final JSON Generation and Download ---

    function downloadJson() {
        try {
            const finalConfig = buildFinalConfig();
            if (!finalConfig) return; // buildFinalConfig might return null on error
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(finalConfig, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "updated_langgraph_config.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        } catch (error) {
            console.error("Error preparing JSON for download:", error);
            alert("An error occurred while preparing the configuration for download. Check the console for details.");
        }
    }

    function buildFinalConfig() {
        if (!getAnalyzersNode()) {
            alert("Cannot build final configuration. The core 'parallel_analyzers_coordinator' node is missing.");
            return null;
        }
        // Deep copy to work on a fresh object
        const finalConfig = JSON.parse(JSON.stringify(configData));
        const analyzersNode = finalConfig.nodeDefinitions.find(n => n.id === 'parallel_analyzers_coordinator');
        const currentAnalyzers = analyzersNode.analyzerTasks;

        // 1. Reconstruct developerInstructionsTemplate for all tasks
        currentAnalyzers.forEach(task => {
            task.promptConfig.developerInstructionsTemplate = reconstructDeveloperInstructions(task);
            delete task.parsedExamples; // Clean up temporary data
            delete task.instructionsText;
        });

        // 2. Define IDs of core nodes we'll be modifying
        const PARALLEL_COORDINATOR_ID = 'parallel_analyzers_coordinator';
        const SYNTHESIZER_ID = 'synthesizer';
        const DATA_COLLECTOR_ID = 'data_collector_for_saver';

        // 3. Remove all old reverters and their associated edges
        const analyzerIds = new Set(currentAnalyzers.map(a => a.id));
        const oldReverterIds = new Set();
        finalConfig.nodeDefinitions = finalConfig.nodeDefinitions.filter(node => {
            if (node.functionName === 'revertGenericAnalyzerHeadline') {
                oldReverterIds.add(node.id);
                // Keep the reverter only if its corresponding analyzer still exists
                const analyzerResultKey = node.stateInputArgs.analyzer_result_object.replace('_result', '');
                return analyzerIds.has(analyzerResultKey);
            }
            return true;
        });
        
        // Remove edges connected to old reverters that were fully removed
         finalConfig.graphEdges = finalConfig.graphEdges.filter(edge => {
            return !(oldReverterIds.has(edge.source) || oldReverterIds.has(edge.target));
         });

        // 4. Rebuild dependencies from scratch based on current analyzers
        const synthesizerNode = finalConfig.nodeDefinitions.find(n => n.id === SYNTHESIZER_ID);
        const dataCollectorNode = finalConfig.nodeDefinitions.find(n => n.id === DATA_COLLECTOR_ID);
        
        // Reset inputs
        synthesizerNode.stateInputArgs = { "headlineToSynthesize": "headlineToAnalyze" };
        dataCollectorNode.stateInputArgs = { "input_headline": "input_headline", "main_flipped_headline_from_state": "flipped_headline" };
        
        let synthPromptAnalyses = '';
        let synthPromptSummary = '';

        currentAnalyzers.forEach((analyzer, index) => {
            const analyzerIdBase = analyzer.id.replace('_analyzer', '');
            const reverterId = `${analyzerIdBase}_reverter`;
            const reverterDisplayName = `Revert ${analyzerIdBase.replace(/_/g, ' ')} Suggestion`;
            const analysisResultKey = analyzer.stateOutputKey;
            const revertedHeadlineKey = `${analyzerIdBase}_reverted_headline`;
            
            // Add Reverter Node if it doesn't exist
            if (!finalConfig.nodeDefinitions.some(n => n.id === reverterId)) {
                finalConfig.nodeDefinitions.push({
                    id: reverterId,
                    displayName: reverterDisplayName,
                    type: "local_function",
                    functionName: "revertGenericAnalyzerHeadline",
                    stateInputArgs: {
                        analyzer_result_object: analysisResultKey,
                        properNoun_map: "properNoun_map"
                    },
                    stateOutputKey: revertedHeadlineKey
                });
            }

            // Add Edges if they don't exist
            const edgeToReverter = { source: PARALLEL_COORDINATOR_ID, target: reverterId };
            const edgeFromReverter = { source: reverterId, target: DATA_COLLECTOR_ID };
            if (!finalConfig.graphEdges.some(e => e.source === edgeToReverter.source && e.target === edgeToReverter.target)) {
                 finalConfig.graphEdges.push(edgeToReverter);
            }
            if (!finalConfig.graphEdges.some(e => e.source === edgeFromReverter.source && e.target === edgeFromReverter.target)) {
                 finalConfig.graphEdges.push(edgeFromReverter);
            }

            // Add inputs to Synthesizer and Data Collector
            const analysisArgKey = `analysis${index + 1}`;
            synthesizerNode.stateInputArgs[analysisArgKey] = analysisResultKey;
            dataCollectorNode.stateInputArgs[revertedHeadlineKey] = revertedHeadlineKey;
            
            // Build parts of the synthesizer prompt
            synthPromptAnalyses += `   - ${analyzer.displayName}: {{${analysisArgKey}}}\n`;
            synthPromptSummary += `      "${analyzer.id}_had_error": {{${analysisArgKey}.error ? true : false}}${index < currentAnalyzers.length - 1 ? ',' : ''}\n`;
        });
        
        // 5. Reconstruct the synthesizer prompt
        const synthPromptTemplate = synthesizerNode.promptConfig.developerInstructionsTemplate;
        const newSynthPrompt = synthPromptTemplate
            .replace(/2\. Review the provided analyses:[\s\S]*?3\. Based on these/, `2. Review the provided analyses:\n${synthPromptAnalyses}3. Based on these`)
            .replace(/"analysis_summary_used":\s*\{[\s\S]*?\}/, `"analysis_summary_used": {\n${synthPromptSummary}  }`);

        synthesizerNode.promptConfig.developerInstructionsTemplate = newSynthPrompt;

        return finalConfig;
    }

    </script>
</body>
</html>